% add ref biblio passive radar IEEE
\documentclass[compress,10pt]{beamer}
\usepackage{url,verbatim,amsmath}

\setbeamertemplate{background canvas}[vertical shading][bottom=white,top=structure.fg!25]
\usetheme{Hannover}
\setbeamertemplate{headline}{}
\setbeamersize{text margin left=0cm}
\graphicspath{{../images/}{./gnuradioDays2019/}}

\beamertemplatefootpagenumber
\beamertemplatenavigationsymbolsempty
\definecolor{mygreen}{rgb}{0,0.6,0}

\usepackage{color}
\definecolor{grey}{rgb}{0.95,0.95,0.95}
\definecolor{keyword}{rgb}{0,0,0.95}
\definecolor{comment}{rgb}{0.95,0,0}
%\definecolor{include}{rgb}{0.55,0,0}
\definecolor{string}{rgb}{0,0.55,00.95}

\usepackage{listings}
\lstset{%backgroundcolor=\color{grey},
        language=C,
        numbers=left,
        numbersep=6pt,
        basicstyle=\tiny\ttfamily,
        extendedchars=true,
        tabsize=3,
        keywordstyle=\color{keyword}\bfseries,
        commentstyle=\color{comment},
%       includestyle=\color{include},
        stringstyle=\color{string}\itshape,
        columns=fullflexible,
        keepspaces=true
}

\setbeamertemplate{footline}{28 Nov 2019, Swiss Aeropole, Payerne (CH)}

\begin{document}
\author[G. Goeavec- Merou \& al.]{Goavec-Merou, Jean-Michel Friedt\\
{\footnotesize
FEMTO-ST Time \& Frequency department, Besan\c con, France \\ 
}
Contact: {\tt \{gwenhael.goavec,jmfriedt\}@femto-st.fr} \\ \vspace{0.6cm}
\begin{center}
Slides at \\
\url{https://github.com/oscimp/oscimpDigital/tree/master/doc/tutorials/plutosdr/2-PRN_on_PL}\\\ \\ \ \\
\includegraphics[height=1cm]{logo_femto.pdf}\vspace{-1cm}
\end{center}
}
\title[]{OscImpDigital CPU-FPGA co-design framework in the context of satellite communication}

\begin{frame}
\titlepage
\end{frame}

%Software Defined Radio (SDR) provides a flexible framework for addressing multiple communication modes and reconfiguring a single hardware platform to match the requirements of several communication systems. Since the datarate is defined by communication bandwidth, maximizing sampling rate is often desirable if only to compensate for Doppler shift of the moving source, requiring a Field Programmable Gate Array (FPGA) as processing frontend between the Analog to Digital Converter (ADC) and general purpose Central Processing Unit (CPU). However, the hassle of developing on the FPGA compared to the flexible frameworks running on general purpose CPU, most significantly GNU Radio [0], drives the need to find the optimum boundary between FPGA and CPU processing defined by bandwidth and processing complexity. Addressing such challenges is met by the OscImpDigital [1] CPU-FPGA co-design framework in which a consistent set of signal processing blocks are provided to run on the FPGA, with the associated Linux module driver for configuring the selected blocks and libraries for accessing these drivers from userspace.

%We demonstrate the use of the OscImpDigital framework on the PlutoSDR SDR platform for receiving GPS signals. Since GPS signal is below thermal noise, pulse compression (correlating with each satellite Gold code) is mandatory to acquire the constellation, i.e. identifying the visible satellites and their Doppler shift. Rather than using the PlutoSDR as a basic SDR source with a communication bandwidth limited by the USB connection to the personal computer, all processing is run on the embedded Zynq System on Chip, making the most of the embedded FPGA and dual CPU for a fully autonomous processing system.

%[0] https://www.gnuradio.org/ and https://github.com/buildroot/buildroot/tree/master/package/gnuradio
%[1] https://github.com/oscimp/oscimpDigital/
%[2] https://github.com/oscimp/oscimpDigital/tree/master/doc/tutorials/plutosdr/2-PRN_on_PL

\section{GPS}
\begin{frame}\frametitle{Why SDR-based GNSS decoding~?}

\begin{enumerate}
\item Flexibility of adding new features without updating hardware
\item Beyond timing \& positioning: access to the raw I/Q stream
\begin{itemize}
\item basic physics (reflectometry)
\item security (phased array for spoofing detection)
\item 1575.42~MHz within range of the PlutoSDR (AD9363 + Zynq SoC)
\end{itemize}
\end{enumerate}

\vfill
\begin{center}
\includegraphics[width=.7\linewidth]{fig2}\\
\includegraphics[width=.7\linewidth]{../images/DSC_0279.JPG}
\end{center}

\end{frame}

\begin{frame}\frametitle{Basics on GPS encoding}

\begin{enumerate}
\item CDMA (Code Division Multiple Access): all satellites transmit on the same frequency
and their messages are encoded with individual orthogonal codes (Gold Codes)
\item Satellite identification: $xcorr(signal,code)$
\item Code orthogonality: $xcorr(code_i,code_j)=\delta_{i,j}$
\item Doppler shift: need to compensate for remote clock frequency wrt ground clock \& local clock
offset wrt remote atomic clocks
\end{enumerate}

\begin{center}
\only<1>{\includegraphics[width=\linewidth]{cdma}}
\only<2>{
\fbox{\parbox{0.8\linewidth}{
\begin{center}
Intensive use of correlations
\footnote{
Time-domain implementation on FPGA allows for pipelined computation as samples are collected
}
 \\$xcorr(x,y)(\tau)=\int x(t)y(t+\tau)dt$ \\or through the
convolution theorem: $FFT(xcorr(x,y)(\tau))=FFT(x)\cdot FFT(y^*)$ 
\end{center}
}}}
\end{center}

\end{frame}

\begin{frame}[fragile]\frametitle{Basics on GPS encoding}

GPS acquisition in 10~lines of Matlab program
\footnote{\tiny using the C/A code generator
\url{https://www.mathworks.com/matlabcentral/fileexchange/14670-gps-c-a-code-generator}} (two nested loops -- satellite number and frequency)

\begin{lstlisting}[language=Matlab]
pkg load signal
x=read_complex_binary(filename,1024*128); fs=1.023; % sampling rate in MHz
x=x-mean(x);
freq0=[-10.5e3:500:10.5e3];                         % Doppler range
time=[0:1/fs/1e6:length(x)/fs/1e6]';time=time(1:end-1);
for m=[1:31]                                        % loop on all satellites
   a=cacode(m,fs/1.023); a=a-mean(a);
   l=1;
   for freq=freq0                                   % loop on all frequency offsets
     mysine=exp(j*2*pi*(-freq)*time); 
     xx=x.*mysine;                                  % frequency shift the signal
     [u(l,m),v(l,m)]=max(abs(xcorr(a,xx,'none')));  % check for cross correlation max.
     l=l+1;
   end
end
\end{lstlisting}

\vspace{-0.70cm}
\begin{minipage}[t]{\linewidth}
\begin{minipage}{.49\linewidth}
{\footnotesize 
\begin{itemize}
\item Orbital mechanics: $Doppler\in [-5000 , 5000]$~Hz
\item Map xcorr max as a function of space vehicle number and frequency shift
\item When a satellite is visible, sharp xcorr peak when frequency offset is compensated for
\end{itemize}
}
\end{minipage}
\begin{minipage}{.49\linewidth}
\includegraphics[width=\linewidth]{../190524gps_xcorr/gps_bin100Hz}
\end{minipage}
\end{minipage}
\end{frame}

\begin{frame}[fragile]\frametitle{Basics on GPS encoding}

GPS acquisition in 10~lines of Matlab program (single loop on space vehicle number)

\begin{lstlisting}[language=Matlab]
pkg load signal
x=read_complex_binary(filename,1024*128); fs=1.023; % sampling rate in MHz
x=x-mean(x);
freq0=[-10.5e3:500:10.5e3];                         % Doppler range
time=[0:1/fs/1e6:length(x)/fs/1e6]';time=time(1:end-1);
% doppler frequency shift matrix whose FFT is computed
doppler=exp(j*2*pi*freq0'*time');                   % 43x131072 matrix
data=ones(43,1)*x';
all=doppler.*data;                                  % Doppler-shifted data
allf=fft(all');
for m=[1:31]                                        % loop on all satellites
  a=cacode(m,fs/1.023);                             % CA code of satellite m
  a=[a zeros(1,length(all)-length(a))];             % zero padding
  a=a-mean(a);
  pattern=ones(43,1)*a;                             % 43x131072 matrix
  af=fft(pattern');
  correlation=ifft(af.*conj(allf))';
end
\end{lstlisting}

\vspace{-0.71cm}
\begin{minipage}[t]{\linewidth}
\begin{minipage}{.49\linewidth}
{\footnotesize 
\begin{itemize}
\item Replace loops (inefficient) with matrix multiplication
\item Parallelizing the frequency operations halves the computation time
\end{itemize}
}
\end{minipage}
\begin{minipage}{.49\linewidth}
\includegraphics[width=\linewidth]{../190524gps_xcorr/gps_bin100Hz}
\end{minipage}
\end{minipage}
\end{frame}

\section{Embedded computation}
\begin{frame}[fragile]\frametitle{Using the embedded FGPA}

\begin{itemize}
\item
GNU/Octave implementation: 1 to 2 second/satellite \\
$\Rightarrow$ $\simeq$1~min for acquisition depending on frequency steps
\item The PlutoSDR Zynq is only used for data collection and transfer to the PC (bandwidth
limited by USB)
\item Preprocessing on the Zynq FPGA removes the communication bandwidth bottleneck
\item Making best use of the available resources on the embedded FPGA (PL)
\item Possible additional pre-processing on the embedded CPU (PS) running GNU Radio before sending
over USB
\end{itemize}

\includegraphics[width=.31\linewidth]{../images/DSC_0275.JPG}
\includegraphics[width=.68\linewidth]{../images/xcorr_pluto2}
\end{frame}

\begin{frame}[fragile]\frametitle{Principle}

\begin{center}
\includegraphics[width=\linewidth]{plutopluto-oscimpDigital-makerspace}
\end{center}

\begin{itemize}
\item PL: collect data from AD9363, frequency transposition (NCO), Gold Code generation \& correlation
\item PS: loop frequency, loop space vehicle number, fetch correlation, control AD9363 (libiio)
\end{itemize}

Complex interaction between FPGA processing blocks and processor userspace through
Linux drivers (modules)
\end{frame}

\section{OscimpDigital}

%\begin{frame}[fragile]\frametitle{The OscimpDigital framework}
%
%\vspace{-0.2cm}
%\hspace{-0.5cm}
%\begin{minipage}[t]{\linewidth}
%\begin{minipage}{0.8\linewidth}
%\hspace{-0.6cm}
%\begin{itemize}
%\item one algorithm $\Rightarrow$ one or more flavor (data type, performance vs.
%resources, ...): {\tt fpga\_ip} directory
%\item need to communicate between FPGA and CPU: {\tt linux\_driver} directory
%\item some IPs are widely used or complex to configure \\$\Rightarrow$ need
%to provide library with CPU code (reduce redundance, simplify application): {\tt
%liboscimp} in {\tt lib} directory.
%\end{itemize}
%\end{minipage}
%\begin{minipage}{0.1\linewidth}
%\center\includegraphics[width=2.6\textwidth]{./img/structureEco}
%\end{minipage}
%\end{minipage}
%\end{frame}


\frame{\frametitle{Oscimp EcoSystem}
Purpose: provide a coherent environment to create design (FPGA), and
application:

\vspace{-0.3cm}
\begin{minipage}[t]{\linewidth}
\begin{minipage}{0.6\linewidth}
\hspace{-0.2cm}
\begin{itemize}
\item blocks (IP) with algorithm level of implementation (FPGA);
\item GNU/Linux hierarchy compliance (driver/library/application);
\item tools to generate some files and scripts/Makefile to factorize most common
part.
\end{itemize}
\end{minipage}
\begin{minipage}{0.3\linewidth}
\center\includegraphics[width=0.7\textwidth]{./img/structureEco}
\end{minipage}
\end{minipage}
\vspace{-0.5cm}
\center\includegraphics[width=1.0\textwidth]{./img/structRepo}
}
%\frame{\frametitle{Structure}
%}
\frame{\frametitle{FPGA}
\begin{minipage}[t]{\linewidth}
\begin{minipage}{0.6\linewidth}
Algorithms or utilities functions.

Developer aspect:
\begin{itemize}
\item normalize interfaces between blocks
\item isolation between implementation and communication
\end{itemize}

End user aspect:
\begin{itemize}
\item 0, 1 or more interface to connect;
\item AXI interface automatically connected.
\end{itemize}
\end{minipage}
\begin{minipage}{0.35\linewidth}
\includegraphics[width=1.2\textwidth]{./img/structureIp}
\end{minipage}
\end{minipage}
\includegraphics[width=0.9\textwidth]{./img/displayIf}
}
\frame{\frametitle{CPU: environment}
{\bf Char device drivers} to add abstraction, GNU/Linux hierarchy compliance and
communication improvement:
\begin{itemize}
\item 1 IP with communication $\Rightarrow$ 1 (or more) driver(s);
\item a {\tt core} driver knows how to communicate with an IP but not where;
\item {\tt device tree overlay} used to provide which drivers must be probed and
base address for each of them;
\end{itemize}
TODO $\Rightarrow$ IIO integration

{\bf libraries} to simplify some common and long (number of line) tasks.
}

\frame{\frametitle{CPU: application}
Application structure:
\begin{itemize}
\item {\tt dts} to provides which driver must be used and base address;
\item {\tt Makefile} to cross-compile application and generate the {\tt dtbo} from dts
\item {\tt applicationName\_us.sh}: a shell script used to flash FPGA, load devicetree
and drivers;
\item {\tt main.c}: user application
\end{itemize}

\includegraphics[width=1.0\textwidth]{img/structApp.pdf}
}

\begin{frame}[containsverbatim]
\frametitle{CPU: module\_generator}
\begin{itemize}
\item Used to generate some files in app directory.
\item use an XML file for design's informations.
\end{itemize}

{\small \verb!module_generator -dts myApp.xml!}

\hspace{-0.6cm}
%\begin{columns}[t]
%\begin{column}{0.57\textwidth}
%myApp.xml
%\vspace{-0.2cm}
{\footnotesize \begin{verbatim}
<?xml version="1.0" encoding="utf-8"?>
<project name="tutorial5" version="1.0">
  <options>
    <option target="makefile" name="USE_STATIC_LIB">1</option>
    <option target="makefile" name="LDFLAGS">-liio</option>
  </options>
  <ips>
    <ip name ="dataComplex_to_ram" >
      <instance name="data1600" id = "0"
        base_addr="0x43c00000" addr_size="0xffff" />
    </ip>
    <ip name ="nco_counter">
      <instance name="nco" id = "0"
        base_addr="0x43c10000" addr_size="0xffff" />
    </ip>
  </ips>
</project>
\end{verbatim}
}
\end{frame}

\begin{frame}[fragile]\frametitle{Application to GPS decoding}

\begin{itemize}
\item
TCL scripts define the processing functions, their settings and how they are 
connected to each other
\item Zynq on the PlutoSDR $\Rightarrow$ Xilinx Vivado (despite platform
independence of OscimpDigital)
\end{itemize}

\begin{center}
\includegraphics[width=1.04\linewidth]{2xcorr_2PRN_NCO_crop.pdf}
{\footnotesize Dual PRN generator and cross-correlation with the received datastream frequency
transposed using the NCO.\par}
\end{center}

\vfill
{\bf 22~s on Zynq PL} (limited by the FPGA area limiting the number of parallel correlations) v.s {\bf 108~s on 2.6 GHz PC} (GNU/Octave)
\end{frame}

\begin{frame}[fragile]\frametitle{Conclusion}

\begin{itemize}
\item OscimpDigital as a flexible framework for assembling signal processing
blocks on the FPGA in charge of collecting radiofrequency data
\item Platform independence (useful investment for Intel/Altera SoC as well)
\item Consistent IP--Linux kernel module--library--userspace application
\item Application to GPS decoding (dual channel, acquisition step)
\item {\bf Perspective}: port to ADRV9361 (Zynq 7035 $\gg$ 7010)
\end{itemize}

\vfill
\fbox{\parbox{\linewidth}{
Users {\bf not familiar with VHDL will benefit} from this framework since functional
processing blocks are provided
}}

\vfill
\noindent{\bf Resources:}

{\footnotesize
{\url{https://github.com/trabucayre/redpitaya}} (Buildroot BR2\_external)

{\url{https://github.com/oscimp/PlutoSDR}} (Buildroot BR2\_external)

{\url{https://github.com/oscimp/oscimpDigital}} (IP, driver, lib, tools \& doc)
}

\vfill
\noindent{Clone repository and submodules:}

{\footnotesize
{\verb!git clone --recursive https://github.com/oscimp/oscimpDigital.git!}
}
\end{frame}

\end{document}

Remember for synthesizing the project for the PlutoSDR to export the {\tt ADI\_HDL\_DIR} variable
towards the {\tt plutosdr-fw/hdl/} directory. The {\tt design} directory hold the application
demonstration, which is compiled thanks to the provided {\tt Makefile} assuming the Vivado and
OscImpDigital variables have been set properly. Because the datastream in the PlutoSDR is clocked
at {\tt samp\_rate} (as defined by the GNU Radio flowgraph) and so is the GLFSR datastream
provided by GNU Radio Companion, the datarate will be consistent during the correlation process.
Hence, the VHDL implementation of the PRN is ({\tt fpga\_ip/prn/hdl}):

The cross-correlation block parametrization requires defining how many correlations are run
in parallel. Due to the limited resources of the Zynq 7010 fitted on the PlutoSDR, we try to
re-use the same processing blocks as many times as possible. If the sequential processing of the
input stream becomes too long with respect ot the input stream, then parallel branches must
be used. Thus, the definition of {\tt NB\_BLK} is as follows:
\begin{enumerate}
\item let us assume an input stream at 1~Msamples/s, and the internal clock rate of the PlutoSDR
of 100~MHz
\footnote{
FCLK\_CLK0 of sys\_ps7 block is defined as shown by double clicking on the block
and selecting Clock Configuration $\rightarrow$ PL Fabric Clock $\rightarrow$ FCLK\_CLK0=100~MHz.
This information is initially defined in the TCL script {\tt system\_bd.tcl} as
{\tt ad\_ip\_parameter sys\_ps7 CONFIG.PCW\_FPGA0\_PERIPHERAL\_FREQMHZ 100.0}}. 
Then a single cross-correlation {\tt xcorr\_prn\_slow\_complex} can process 
100~correlations before a new input bit is clocked by the datastream
\item one last processing block is always assumed to be added to process the remaining number
of samples. In this case, 27 more correlations will be needed, which can be performed by this
second implicit processing block (since $27<100$)
\item if the clock had only been 50~MHz, then 2~blocks would have been needed: the two blocks
would have processed $2\times 50=100$~correlations sequentially, and the remaining 27 could have
been taken care of by the additional implicit block since $27<50$.
\end{enumerate}

Hence, the TCL file defining the PlutoSDR firmware is appended ({\tt design/system\_bd.tcl}) with
\begin{lstlisting}[language=TCL]
# prn1
ad_ip_instance prn prn1_gen
ad_ip_parameter prn1_gen CONFIG.PERIOD_LEN 1
ad_ip_parameter prn1_gen CONFIG.BIT_LEN 7
ad_ip_parameter prn1_gen CONFIG.PRN_NUM 1

ad_connect sys_ps7/FCLK_CLK0 prn1_gen/clk
ad_connect sys_rstgen/peripheral_reset prn1_gen/reset

[...]

# prn4
[...]

# xcorr1
ad_ip_instance xcorr_prn_slow_complex xcorr1
ad_ip_parameter xcorr1 CONFIG.LENGTH 127
ad_ip_parameter xcorr1 CONFIG.NB_BLK 1
ad_ip_parameter xcorr1 CONFIG.IN_SIZE 16
ad_ip_parameter xcorr1 CONFIG.OUT_SIZE 32

ad_connect duppl_xcorr/data1_out xcorr1/data_in
ad_connect prn1_gen/prn_o xcorr1/prn_i
ad_connect xcorr1/prn_sync_o prn1_gen/tick_i

# xcorr4
[...]

#dataComplex
ad_ip_instance dataComplex_to_ram data_to_ram
ad_ip_parameter data_to_ram CONFIG.NB_INPUT 1
ad_ip_parameter data_to_ram CONFIG.DATA_SIZE 32
ad_ip_parameter data_to_ram CONFIG.NB_SAMPLE 2048

ad_connect xcorr1/data_out data_to_ram/data1_in
ad_connect sys_rstgen/peripheral_reset data_to_ram/s00_axi_reset

ad_cpu_interconnect 0x43C20000 data_to_ram
\end{lstlisting}
defining the first ({\tt PRN\_NUM}) sequence of PRN with 127-length ({\tt BIT\_LEN}) clocked
by the internal 100~MHz clock ({\tt sys\_ps7/FCLK\_CLK0}) and the cross correlation
operates on these 127-bits ({\tt LENGTH}) with a single processing block ({\tt NB\_BLK}) considering
than an implicit second block will take care of the remaining 27~cycles.

\begin{figure}[h!tb]
\caption{PRN generator and cross-correlation with the received datastream.}
\label{ex1}
\end{figure}

We see on this TCL script -- or in Vivado by double-clicking on the Data\_to\_RAM block, that the
data size will be encoded as 32-bit words. Since we are handling complex data, we fetch two 32-bit 
words for each sample, and a total of 2048 samples are stored in the RAM. Hence, the userspace
application for fetching the data will be
\begin{lstlisting}[language=C]
int main()
{int32_t c[2048 * 2 *NUM_PRN]; /* two input (x2) x 2048 sample complex (x2) */
 int fi, fo;
 fi = open("/dev/data3200", O_RDWR);
 fo = open("/tmp/data.bin", O_WRONLY | O_CREAT);
 read(fi, c, 2048 * 2 * NUM_PRN * sizeof(int32_t));
 write(fo, c, 2048 * 2 * NUM_PRN * sizeof(int32_t));
 close(fi);
 close(fo);
}
\end{lstlisting}
and the resulting {\tt /tmp/data.bin} is transfered to the host PC for reading by GNU/Octave (Fig. \ref{res1})
with \\{\tt fd=fopen("data.bin"); a=fread(fd, Inf, "int32"); prn=a(1:2:end)+i*a(2:2:end); plot(abs(prn1));}.

\begin{figure}[h!tb]
\includegraphics[width=\linewidth]{results/example1.pdf}
\caption{Correlation output from the PL processing, left to right with a through connexion
between TX and RX, open circuit or loaded input and output (50~$\Omega$).}
\label{res1}
\end{figure}

The last challenge is the different datarates between the PRN generation and the cross-correlator.
Indeed the cross-correlator is clocked by the 100~MHz AXI bus clock while the input datastream
is clocked at the {\tt samp\_rate} rate. Hence, a FIFO block must be included between the 
output datastream and the cross correlator input (Fig. \ref{ex1}).

Since the 7-bit PRN generator is designed to only generate one pseudo-random sequence out of the 
18 possible options (\url{http://users.ece.cmu.edu/~koopman/lfsr/7.txt}), namely the taps defined 
as 0x41=65 (or $x^7+x^6+1$), we can also use this opportunity to demonstrate the orthogonality of 
the codes needed for CDMA. Indeed cross correlating to null-mean value pseudo-random sequence will 
not allow for coherent energy accumulation and will not yield discrete correlation peaks when 
the two sequences match.

\begin{figure}[h!tb]
% \includegraphics[width=\linewidth]{xcorr_pluto3g.png}
\caption{Running the same PRN sequence on the Zynq PL (receiver side) than the one emitted by 
GNU Radio
allows for identifying cross-correlation peaks separated by the PRN length of 127 samples. Emitting a
different PRN sequence than the one run on the Zynq PL yield close-to-zero cross correlations, hence
demonstrating the orthogonality of PRN codes.}
\label{f2}
\end{figure}

\section{7-bit PRN on different receive and transmit carrier frequencies}

We are convinced the correlator block is operational and fits in the PL remaining resources (although
decoding 1023-bit long GPS Gold Codes will require extending the correlator length from 127 to 1023 bits,
hence using more resources), and that we understand how to generate PRN sequences matching incoming patterns.

\begin{figure}[h!tb]
\includegraphics[width=\linewidth]{xcorr_pluto3ng.png}
\includegraphics[width=\linewidth]{xcorr_pluto3g.png}
\caption{Offsetting the emitted frequency with respect to the received frequency (top) prevents
the cross-correlation from accumulating energy due to the null mean power of the trigonometric
functions. Compensating for the frequency offset solves the issue (bottom), as will be needed
in the case of GPS reception due to the Doppler frequency shift associated with satellite motion.}
\label{f3}
\end{figure}

However, GPS satellites are not geostationary but moving along their orbit at an altitude of 20000~km. Basic
celestial mechanics tells us that the period is 12~hours, and dividing the orbit length by the period gives
us the satellite velocity from which the Doppler shift is deduced. We expect Doppler shifts in the $\pm 5$~kHz 
range, while the cross-correlation of the 1023-bit long code running at 1.023~Mb/s will be canceled for
any frequency offset of more than 1~kHz (inverse of 1~ms repetition rate) due to the zero-mean value of trigonometric
functions. Practically, good signal to noise ratio will be achieved if the receiver frequency is not offset
by more than 500~Hz from the emitter frequency. Hence, Doppler shift compensation on the receiver side is needed:
the {\bf acquisition} phase of GPS reception means sweeping all possible Space Vehicle (SV$\in[1..32]$) code and 
all possible Doppler frequency shifts to try and find which satellite is at what position. This step will be 
addressed in this document, while the following {\bf tracking} phase will not be addressed.

Back to basics, we wish to demonstrate on the 7-bit long PRN sequence how a frequency offset between emitter
and receiver can be compensated for by including a PS-configurable Numerically Controlled Oscillator (NCO) and
mixing the incoming signal prior to correlating. Again we first start demonstrating the concept using GNU Radio
prior to extending the demonstration to the Zynq PL. Fig. \ref{f3} demonstrates using GNU Radio's Frequency 
Xlating FIR Filter to compensate for the frequency offset introduced on purpose between the PlutoSDR emitter and 
receiver. Fig. \ref{f3} indeed demonstrates that the correlation remains null for high frequency offsets and
that the correlation peaks re-appear once the frequency offset has been compensated for.

The challenge of implementing the NCO in the FPGA is that we must know what the sampling frequency is, {\em i.e.}
know the clock rate of the NCO block. We have identified that the frequency of the signal propagated in the 
FPGA is given by reading\\
{\tt /sys/bus/iio/devices/iio\:device1/in\_voltage\_sampling\_frequency}\\
which tells us that the GNU Radio {\tt samp\_frequency} is the clock signal frequency in the PL.

% {\bf TODO: describe NCO and complex mixer}
The PL implementation is quite similar except that this time the NCO must be included
between the datastream -- running at {\tt samp\_rate} -- and the FIFO feeding the correlator (Fig.
\ref{ex2}).

\begin{figure}[h!tb]
\includegraphics[width=\linewidth]{1xcorr_1PRN_NCO_crop.pdf}
\caption{PRN generator and cross-correlation with the received datastream with frequency
transposition using the NCO.}
\label{ex2}
\end{figure}

In order to demonstrate both frequency shifting capability and dual-PRN detection to select
one emitter or the other, two PRN generators and two correlators can be included in the
decoding path (Fig. \ref{ex3}).

\begin{figure}[h!tb]
\label{ex3}
\end{figure}

\section{GPS signal reception}

The knowledge acquired so far now allows us to tackle GPS acquisition. During this
initialization phase in which the receiver does not know what its local oscillator offset is,
which satellite is visible and where they are located in the sky, a brute force approach is needed
to try all possible satellite identifiers with all possible Doppler shifts\footnote{the receiver
can actually get a hint of the Doppler shifts to be investigated by squaring the BPSK signal
and looking at the spectral components of the Fourier transform of the resulting signal. Since
squaring a BPSK modulated signal gets rid of the modulation, strong spectral components will be
visible at twice the offset frequency.}. Hence, the NCO is programmed with narrow enough frequency
steps to sweep all possible Doppler shifts, and all possible space vehicle PRNs are correlated
with the frequency transposed I/Q signal. GPS does not use a basic 10-bit long PRN but the so-called
Gold code provided in the {\tt cacode} FPGA IP. Notice that this same function is available for
Matlab or GNU/Octave at \url{https://www.mathworks.com/matlabcentral/fileexchange/14670-gps-c-a-code-generator}
and will be used later in the software-decoding of GPS.

The first step is to assess the hardware setup and being able to collect I/Q streams using the 
PlutoSDR tuned to the GPS carrier frequency of 1575.42~MHz (Fig. \ref{f4}). Since our NCO only accepts positive
frequencies, we actually slightly offset the carrier frequency so that the Doppler correction is
achieved only by programming positive frequencies when configuring the NCO.

\begin{figure}[h!tb]
\includegraphics[width=\linewidth]{DSC_0279.JPG}
\caption{Experimental setup: a bias-T is introduced between the PlutoSDR RX input and the
GPS antenna to power the antenna amplifier. A radiofrequency-grade 1 to 100~$\mu$H inductor
connected to the +5~V power supply and a 1~nF capacitor to the receiver will provide similar 
results.} 
\label{f4}
\end{figure}

While {\tt cacode} outputs all SV sequences, the space available on the Zynq-7010 of the PlutoSDR only
allows for synthesizing a single cross-correlating block for 1023-bit long sequences. Hence, the
Zynq PS is programmed to configure a single SV identifier, and then sweep NCO values. Since the 
1023-bit long is run at 1.023~Mb/s on the GPS satellite, the code repeats every millisecond. To make
sure we observe a fine correlation peak, we sweep the frequency with 300~Hz steps.

\begin{figure}[h!tb]
\includegraphics[width=.49\linewidth]{190524gps_xcorr/gps_bin100Hz.pdf}
\includegraphics[width=.49\linewidth]{190524gps_xcorr/gps_plutosdr.pdf}
\caption{Left: cross-correlation (color code) maximum as a function of SV number (abscissa) and frequency
offset (ordinate) as computed using GNU/Octave on a 250~ksamples record collected from the
PlutoSDR. Right: same computation as performed on the Zynq PL. The results are consistent with space
vehicles 16, 21, 26, 29 and 31 clearly visibles at frequency offsets within the $\pm$5~kHz range expected
from the Doppler shift. No local oscillator bias is seen on this PlutoSDR.}
\label{f5}
\end{figure}

Running all SV identifiers and for each SV, running all frequency offsets in a $\pm 100$~kHz range (to account
for possible local oscillator bias) requires 1 minute and 50 seconds for 100~Hz steps and 31 satellites
(Fig. \ref{f5}, bottom right) or 36 seconds for 300~Hz steps. Mapping the constellation of satellites
with 500~Hz steps (Fig. \ref{f5}, bottom left) is hence expected to require only 22~seconds when running on
the computation on the PL. The same computation result (500~Hz steps, 31 satellites) requires 108 seconds
on a 2.60~GHz i5-3320M CPU as found in the Panasonic CF-19 running GNU/Octave, while the displayed chart
(100~Hz steps) required 504~seconds using the following program:
\begin{lstlisting}[language=octave]
pkg load signal
x=read_complex_binary('./gps.bin');
fs=1.023; % MHz                   % sampling frequency
freq0=[-1.0e4:500:1.0e4]-20000;   % frequency range
x=x(1:2e5);                       % data subset
time=[0:1/fs/1e6:length(x)/fs/1e6]';time=time(1:end-1); % discrete time
for m=[1:31]                      % PRN number
   a=cacode(m,fs/1.023); a=a-mean(a);
   l=1; m
   for freq=freq0                 % run through possible frequency offsets
    mysine=exp(j*2*pi*(-freq)*time); 
    xx=x.*mysine;                 % frequency shift the signal
    [u(l,m),v(l,m)]=max(abs(xcorr(a,xx))); % check for cross correlation max.
    l=l+1;
   end
end
imagesc([1:31],-freq0-20000,abs(u))
\end{lstlisting}

\begin{thebibliography}{9}
\bibitem{collins} T.F. Collins, R. Getz, D. Pu \& A.M. Wyglinski, {\em Software-Defined 
Radio for Engineers}, Artech House (2018), p.171 at
\url{www.analog.com/en/education/education-library/software-defined-radio-for-engineers.html}
\end{thebibliography}
\end{document}
